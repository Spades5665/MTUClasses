/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%union{
  char *str;
  struct expr *expression;
}

%type <expression> program list expr term factor

%token<str> TOKEN_ID
%token TOKEN_INTEGER
%token TOKEN_INT
%token TOKEN_SEMI
%token TOKEN_PLUS
%token TOKEN_MINUS
%token TOKEN_MUL
%token TOKEN_DIV
%token TOKEN_LPAREN
%token TOKEN_RPAREN
%token TOKEN_SIN
%token TOKEN_COS
%token TOKEN_END
%token TOKEN_EQU

%{

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "expr.h"

extern struct SymbolTable symtab;

//YYSTYPE is the lexical value returned by each rule in a bison grammar. By default, it is an integer. In this example, we are returning a pointer to an expression.
#define YYERROR_VERBOSE 1

//Clunky: Manually declare the interface to the scanner generated by flex.
extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

//Clunky: Keep the final result of the parse in a global variable, so that it can be retrieved by main().
struct expr * parser_result = 0;

%}

%%

/* Here is the grammar: program is the start symbol. */

program: list TOKEN_END
	       {
				parser_result = $1;
				return 0;
		   }
	   ;

list: list expr TOKEN_SEMI
		{
			printf("parse successful: ");
			expr_print($2);
			printf("\nevaluates to: %d\n", (int) expr_evaluate($2));
			$$ = $2;
		}
	| expr TOKEN_SEMI
		{
			printf("parse successful: ");
			expr_print($1);
			printf("\nevaluates to: %d\n", (int) expr_evaluate($1));
			$$ = $1;
		}
	;

expr: expr TOKEN_PLUS term
		{$$ = expr_create(EXPR_ADD, $1, $3, "", 0);}
	| expr TOKEN_MINUS term
		{$$ = expr_create(EXPR_SUBTRACT, $1, $3, "", 0);}
	| term
		{$$ = $1;}
	;

term: term TOKEN_MUL factor
		{$$ = expr_create(EXPR_MULTIPLY, $1, $3, "", 0);}
	| term TOKEN_DIV factor
		{$$ = expr_create(EXPR_DIVIDE, $1, $3, "", 0);}
	| factor
		{$$ = $1;}
	;

factor: TOKEN_LPAREN expr TOKEN_RPAREN
	      {$$ = $2;}
	  | TOKEN_MINUS factor
		  {$$ = expr_create(EXPR_SUBTRACT, expr_create(EXPR_VALUE, 0, 0, "", 0), $2, "", 0);}
	  | TOKEN_SIN TOKEN_LPAREN expr TOKEN_RPAREN
	      {$$ = expr_create(EXPR_SIN, 0, $3, "", 0);}
	  | TOKEN_COS TOKEN_LPAREN expr TOKEN_RPAREN
	      {$$ = expr_create(EXPR_COS, 0, $3, "", 0);}
	  | TOKEN_INT
		  {$$ = expr_create(EXPR_VALUE, 0, 0, "", atoi(yytext));}
	  | TOKEN_ID
	      {
              struct KeyValuePair* pair = getAddr_symTab(&symtab, $1, 0);
			  free($1);
		      $$ = expr_create(EXPR_VALUE, 0, 0, "", pair->value);
		  }
	  | TOKEN_ID TOKEN_EQU expr
		  {
			  struct KeyValuePair* pair = insert(&symtab, $1, expr_evaluate($3));
			  free($1);
			  $$ = expr_create(EXPR_EQU, 0, $3, pair->key, pair->value);
		  }
	  ;

%%

int yyerror(char *str) {
	printf("parse error: %s\n", str);
	return 0;
}
